\chapter*{Приложение Б Порядок выполнения лабораторной работы \No2}
\refstepcounter{chapter}
\addcontentsline{toc}{chapter}{Приложение Б Порядок выполнения лабораторной работы \No2}
\begin{enumerate}
\item Создать в папке с номером группы на рабочем столе папку \verb#Lab2# для файлов проекта.
\item Скопировать в созданную папку \verb#Lab2#, папку \verb#CMSIS# из папки \verb#Лабораторные работы по микроконтроллерам/Materials# на рабочем столе.
\item Создать и настроить проект в среде разработки IAR. В качестве имени проекта указать \textit{lab1}, все файлы настроек проекта сохранить в папке
\verb#Lab2# (Настройка проекта происходит, как указано в первой лабораторной работе).
\item Добавить в созданную папку с проектом файлы \textit{stm32l\_discovery\_lcd.c, stm32l\_discovery\_lcd.h, discover\_board.h} из папки \verb#Лабораторные работы по микроконтроллерам/Materials/Discovery# и внести их в проект.
\item Добавить в созданную папку с проектом файл \textit{stm32l1xx\_conf.h} из папки \verb#Лабораторные работы по микроконтроллерам/Materials#, добавить его в проект.
\item Добавить в созданную папку с проектом папку \verb#STM32L1xx_StdPeriph_Driver# из папки \verb#Лабораторные работы по микроконтроллерам/Materials#, добавить в проект IAR файлы \textit{stm32l1xx\_lcd.c, stm32l1xx\_lcd.h, stm32l1xx\_gpio.h, stm32l1xx\_gpio.с, stm32l1xx\_rcc.h, stm32l1xx\_rcc.c}.
\item В добавленные файлы из папки \verb#STM32L1xx_StdPeriph_Driver# добавить
\begin{verbatim}
#include "stm32l1xx_conf.h"
\end{verbatim}
\item Добавить в проект файл \textit{stm32l1xx.h} из папки \verb#Лабораторные работы по микроконтроллерам/Materials/CMSIS#
\verb#/DeviceSupport/ST/STM32L1xx#.
\item К добавленным папкам и файлам прописать пути во вкладке \textit{Preprocessor} в настройках проекта.
\item Получить от преподавателя 3 слова для вывода на ЖКИ.
\item Реализовать вывод первого заданного преподавателем слова используя регистры \textit{LCD->RAM[x]}.
\item Реализовать вывод второго заданного преподавателем слова используя библиотеку для работы с ЖКИ.
\item Реализовать бегущую строку на основе третьего полученного слова используя библиотеку для работы с ЖКИ.
\item Написать программу для микроконтроллера на языке Си.
\item Подключить отладочную плату STM32L - Discovery к компьютеру.
\item Загрузить программу в микроконтроллер и произвести ее отладку.
\item Отчет.
\end{enumerate}
\section{Пример выполнения лабораторной работы \No2}
На ЖКИ выводится, с использованием регистров \textit{LCD->RAM[x]}, надпись <<KAF403>>. С использованием библиотечной функции выводится бегущая строка <<MAI>>, с использованием библиотечной функции выводится строка <<FRELA>>.

Пример главной программы для микроконтроллера.
\begin{verbatim}
#include "stm32l1xx.h"
#include "stm32l_discovery_lcd.h"

static uint32_t TimingDelay;
//Прототип функции инициализации портов микроконтроллера
void gpio(void);
//Прототип функции инициализации контроллера ЖКИ
void controller(void);
//Прототип функции временной задержки в миллисекундах
void delay(uint32_t);
void main(void)
{
  gpio();
  controller();
  //Вызов функции конфигурации системного таймера SysTick, 
  //определенной в core_cm3.h
  SysTick_Config(2097);
  while(1)
  {
    while(LCD->SR & LCD_SR_UDR);
    //Вывод информации на ЖКИ через регистры
    LCD->RAM[0] = 0x2E369985;
    LCD->RAM[2] = 0x2F2EF880;
    LCD->RAM[4] = 0x10000000;
    LCD->RAM[6] = 0x1;
    //Конец вывода
    LCD->SR |= LCD_SR_UDR;
    delay(3000);//Задержка 3 секунды
    LCD_GLASS_Clear();//Очистили ЖКИ
    
    //Бегущая строка, 1-количество повторений, 200 - задержка в 
    //миллисекундах перед обновлением информации на ЖКИ
    LCD_GLASS_ScrollSentence("      MAI",1,200);
    
    //Вывод на ЖКИ слова FRELA
    LCD_GLASS_DisplayString("FRELA");
    delay(2000);
  } 
}
// Функция инициализации портов микроконтроллера
void gpio(void)
{
  RCC->AHBENR |= 0x7;
  GPIOA->MODER |= 0x802A00A8;
  GPIOB->MODER |= 0xAAAA0A80;
  GPIOC->MODER |= 0xAAA0AA;
  GPIOA->OTYPER &= ~0x870E;
  GPIOB->OTYPER &= ~0xFF38;
  GPIOC->OTYPER &= ~0xFCF;
  GPIOA->PUPDR &= ~0xC03F00FC;
  GPIOB->PUPDR &= ~0xFFFF0FC0;
  GPIOC->PUPDR &= ~0xFFF0FF;
  GPIOA->OSPEEDR &= ~0xC03F00FC;
  GPIOB->OSPEEDR &= ~0xFFFF0FC0;
  GPIOC->OSPEEDR &= ~0xFFFFF0FF;
  GPIOA->AFR[0] |= 0xBBB0;
  GPIOA->AFR[1] |= 0xB0000BBB;
  GPIOB->AFR[0] |= 0xBBB000;
  GPIOB->AFR[1] |= 0xBBBBBBBB;
  GPIOC->AFR[0] |= 0xBB00BBBB;
  GPIOC->AFR[1] |= 0xBBBB;
}
//Функция инициализации контроллера ЖКИ
void controller(void)
{
  RCC->APB1ENR |= 0x10000200;
  PWR->CR |= 0x100;
  RCC->CSR |= 0x800000;
  RCC->CSR &= ~0x800000;
  RCC->CSR |= 0x100;
  while(!(RCC->CSR&RCC_CSR_LSERDY));
  RCC->CSR |= 0x10000;
  LCD->CR &= ~0x60;
  LCD->CR |= 0x40;
  LCD->CR &= ~0x1C;
  LCD->CR |= 0xC;
  LCD->CR |= 0x80;
  LCD->FCR &= ~0x3C00000;
  LCD->FCR &= ~0x3C0000;
  LCD->FCR |= 0x1040000;
  LCD->FCR &= ~0x1C00;
  LCD->FCR |= 0x800;
  while(!(LCD->SR&LCD_SR_FCRSR));
  LCD->CR &= ~0x2;
  LCD->CR |= 0x1;
  while(!(LCD->SR&LCD_SR_RDY));
  while(!(LCD->SR&LCD_SR_ENS));
}
//Функция временной задержки в миллисекундах
void delay(uint32_t nTime)
{
  TimingDelay = nTime;
  while(TimingDelay != 0);
}
//Обработчик прерывания системного таймера
void SysTick_Handler(void)
{
  if (TimingDelay != 0x00)
  {
    TimingDelay--;
  }
}
\end{verbatim}